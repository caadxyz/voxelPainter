<!DOCTYPE html>
<html>
<head>
    <title>Edytor map</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="css/main.css"/>
</head>
<body>
<script src="js/vendor/three.min.js"></script>
<script src="js/vendor/SceneExporter.js"></script>
<script src="js/vendor/FileSaver.js"></script>

<script src="js/loaders/ctm/lzma.js"></script>
<script src="js/loaders/ctm/ctm.js"></script>
<script src="js/loaders/ctm/CTMLoader.js"></script>

<script src="js/loaders/OBJLoader.js"></script>
<script src="js/loaders/VTKLoader.js"></script>
<script src="js/loaders/STLLoader.js"></script>
<script src="js/loaders/ColladaLoader.js"></script>
<script src="js/loaders/UTF8Loader.js"></script>
<script src="js/loaders/MTLLoader.js"></script>
<script src="js/cameraSettings.js"></script>

<script>

window.URL = window.URL || window.webkitURL;
window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

var container;
var camera, scene, renderer, mainContainer;
var projector;
var mouse2D, mouse3D, raycaster, theta = 45, target = new THREE.Vector3(0, 200, 0);
var isShiftDown = false, isCtrlDown = false, isMouseDown = false, isQDown = false, isRDown = false, isDelDown = false, isTDown=false;

var ROLLOVERED, R;

var allObjectsOnScene = [];

step = 50, sceneHeight = 1, singleHeight = 1;

var selectedIndex=0;
var groupContainer=[];

var map = THREE.ImageUtils.loadTexture( 'crate.jpg');
//zaznaczanie
var selObj = new Object();
var isSelected = 0;
var material = new THREE.MeshLambertMaterial({
    color: 0x6666EE
});

var lineMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    opacity: 0.2
});
var split = false;
var seg = 0;

init();
animate();

function init() {

    container = document.createElement('div');
    document.body.appendChild(container);

    //panels
    var info = document.createElement('div');
    info.style.position = 'absolute';
    info.style.top = '10px';
    info.style.width = '100%';
    info.style.textAlign = 'center';
    info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - voxel painter<br><strong>click</strong>: add voxel, ' +
            '<strong>control + click</strong>: select voxel, <strong>shift</strong>: rotate, <br><strong>click+delete</strong>: remove,' +
            '<strong>asdw</strong>: move, M- creates a group<br><a download="document.json" href="javascript:save(scene,renderer);">save .png</a>';

    var controls = document.createElement('div');
    controls.style.position = 'absolute'
    controls.style.top = '10px'
    controls.style.right = '10px'
    controls.innerHTML = '<input type="range" name="height" id="height" value="1" min="0" max="10">'

    var heightControls = document.createElement('div');
    heightControls.style.position = 'absolute'
    heightControls.style.top = '100px'
    heightControls.style.right = '10px'
    heightControls.innerHTML = '<p>Wysokosc klocka</p><input type="range" name="singleHeight" id="singleHeight" value="1" min="0" max="10">'

    var sceneControls = document.createElement('div');
    sceneControls.style.position = 'absolute'
    sceneControls.style.top = '60px'
    sceneControls.style.right = '10px'
    sceneControls.innerHTML = '<input type="text" name="sceneWidth" id="sceneWidth" value="500"><input type="text" name="sceneHeight" id="sceneHeight" value="500"><button id="sceneSubmit" onClick="updateGrid(document.getElementById(\'sceneWidth\').value,document.getElementById(\'sceneHeight\').value)">zmie� siatk�</button><br/><button onClick="clearGrid()">wyczy�� plansz�</button>'

    var form = document.createElement('div');
    form.innerHTML = '<p>Please specify a fddile, or a set of files:<br><form id="fileUploadForm" enctype="multipart/form-data" action="/upload.php" method="POST"><input type="file" id="input" name="input" size="40"></form></p>'
    form.style.position = 'absolute'
    form.style.top = '10px'
    form.style.left = '10px'
    container.appendChild(form);
    container.appendChild(info);
    container.appendChild(controls);
    container.appendChild(heightControls);
    container.appendChild(sceneControls);


    heightController = document.getElementById('height');

    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.y = 800;

    scene = new THREE.Scene();
    mainContainer = new THREE.Object3D();
    scene.add(mainContainer);

   setLightRenderingAndPlane();
}


/*function lightUpWall(intersects) {

}*/

function onDocumentMouseMove(event) {
    event.preventDefault();

    mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse2D.y = -( event.clientY / window.innerHeight ) * 2 + 1;

    var intersects = raycaster.intersectObjects(allObjectsOnScene, true);

    //var intersects = raycaster.intersectObjects(parent1.children);

    if (intersects.length > 0) {

        if (ROLLOVERED)
        {
            ROLLOVERED.face.color.setHex(0x408080);
            R.colorsNeedUpdate = true;
        }

        ROLLOVERED = intersects[ 0 ];
        console.log(ROLLOVERED.face.color.getHex());
        ROLLOVERED.face.color.setHex(0xff8800);
        //ROLLOVERED.face.emissive.setHex(0xff8800);
        //material.emissive.setHex(0xff0000);
        R = intersects[ 0 ].object.geometry;
        R.colorsNeedUpdate = true;
        /*
         if (ROLLOVERED) ROLLOVERED.material.wireframe = false;

         ROLLOVERED = intersects[ 0 ].object;
         console.log(ROLLOVERED.material.wireframe);
         ROLLOVERED.material.wireframe = true;
         */
    }
}

function onDocumentMouseDown(event) {
    event.preventDefault();
    isMouseDown = true;
    createSegment();
}

function onDocumentMouseUp(event) {

    event.preventDefault();
    isMouseDown = false;
}

function onDocumentKeyDown(event) {
    //console.log(event.keyCode);
    switch (event.keyCode) {

        case 16:
            isShiftDown = true;
            break;
        case 17:
            isCtrlDown = true;
            break;
        case 'Q'.charCodeAt(0):
            isQDown = true;
            break;
        case 'R'.charCodeAt(0):
            isRDown = true;
            break;
        case 46:
            isDelDown = true;
            break;
        case 'M'.charCodeAt(0):
            createGroup();
            break;
        case 'N'.charCodeAt(0):
            splitGroup();
            break;

        //ruch
        case 'I'.charCodeAt(0):
            translateCubes(0, +1, 0);
            break;
        case 'K'.charCodeAt(0):
            translateCubes(0, -1, 0);
            break;
        case 'D'.charCodeAt(0):
            translateCubes(1, 0, 0);
            break;
        case 'A'.charCodeAt(0):
            translateCubes(-1, 0, 0);
            break;
        case 'W'.charCodeAt(0):
            translateCubes(0, 0, -1);
            break;
        case 'S'.charCodeAt(0):
            translateCubes(0, 0, 1);
            break;
        case 'P'.charCodeAt(0):
            scaleCubes(0, 0, 0.1);
            break;
        case 'T'.charCodeAt(0):
            isTDown=true;
            break;

    }

}

function onDocumentKeyUp(event) {

    switch (event.keyCode) {

        case 16:
            isShiftDown = false;
            break;
        case 17:
            isCtrlDown = false;
            break;
        case 81:
            isQDown = false;
            break;
        case 82:
            isRDown = false;
            break;
        case 46:
            isDelDown = false;
            break;
        case 'T'.charCodeAt(0):
            isTDown=false;
            break;

    }
}

function createSegment() {
    var intersects = raycaster.intersectObjects(scene.children, true);

    var INTERSECTED;

    if (intersects.length > 0) {

        if (isMouseDown) {
            if (isCtrlDown) {

                if (intersects[0].object != plane) {
                    if (intersects[0].object.parent==mainContainer)
                    Select1(intersects[0].object);
                    else {
                        selectedIndex=getIndex(intersects[0].object);

                        for(i=0;i<intersects[0].object.parent.children.length;i++)
                            Select1(intersects[0].object.parent.children[i]);

                    }
                }
            }
            else if (isTDown) {

                if (intersects[0].object != plane) {
                    if (intersects[0].object.parent==mainContainer)
                        setTransparency(intersects[0].object);
                    else {
                        selectedIndex=getIndex(intersects[0].object);

                        for(i=0;i<intersects[0].object.parent.children.length;i++)
                            setTransparency(intersects[0].object.parent.children[i]);

                    }
                }
            }
            else if (isQDown) {
                if (intersects[0].object != plane) {
                    splitSegment(intersects[0].object);
                }
            }
            else if (isDelDown) {
                if (intersects[0].object != plane) {
                    if (intersects[0].object.parent==mainContainer)
                        intersects[0].object.parent.remove(intersects[0].object);
                    else {
                        for(i=intersects[0].object.parent.children.length-1;i>=0;--i)
                            intersects[0].object.parent.parent.remove(intersects[0].object.parent);

                    }
                }
            }

            else {
                var position = new THREE.Vector3().add(intersects[0].point, intersects[0].object.matrixRotationWorld.multiplyVector3(intersects[0].face.normal.clone()));
                if (intersects[0].faceIndex != 2) {
                    addSegment(position);
                }
            }
        }

    }
}

function getIndex(obj){
    for (i=0; i< groupContainer.length;i++){
       if (obj.parent== groupContainer[i]){
           console.log("getindex:"+selectedIndex);
           selectedIndex=i;
           break;
       }
    }
    return selectedIndex;
}

function Select1(obj) {

    if (obj != plane) {
         INTERSECTED = obj;

        if (INTERSECTED.material.emissive.getHex() == 0x000000) {
            INTERSECTED.material.emissive.setHex(0xff0000);
            selObj[obj.name] = obj.name;
        }
        else {
            INTERSECTED.material.emissive.setHex(0x000000);
            console.log("wunselekcie"+selectedIndex) ;
            delete selObj[obj.name];
        }
    }
}

function setTransparency(obj){
    var materialWindow = new THREE.MeshLambertMaterial( { map: map, transparent: true } );
    materialWindow.transparent=true;
    materialWindow.opacity = 0.6;

    if (obj != plane) {
        INTERSECTED = obj;

            INTERSECTED.material=materialWindow;
            INTERSECTED.material.emissive.setHex(0xff0000);
    }

    //TODO
}


function addSegment(position) {
    singleHeight = document.getElementById('singleHeight').value;
    var geometry = new THREE.CubeGeometry(50, 50 * singleHeight, 50);
    seg++;
    console.log("ilosc seg:" + seg);
    for (var i = 0; i < geometry.faces.length; i++) {

        geometry.faces[i].color.setHex(0x408080);
    }


    var material = new THREE.MeshLambertMaterial( { map: map, transparent: false } );

    /*var material = new THREE.MeshLambertMaterial({
        vertexColors: THREE.FaceColors
    });*/



    var voxel = new THREE.Mesh(geometry, material);
    voxel.name = "Segment_" + voxel.id;
    voxel.position.x = Math.floor(position.x / 50) * 50 + 25;
    voxel.position.y = Math.floor(position.y / 50) * 50 + 25;
    voxel.position.z = Math.floor(position.z / 50) * 50 + 25;
    voxel.matrixAutoUpdate = false;

    console.log(parseInt(singleHeight) * 50 / 2);
    voxel.position.y = parseInt(singleHeight) * 50 / 2;
    voxel.updateMatrix();
    mainContainer.add(voxel);
    var vox=new THREE.Object3D();
    vox=voxel;
    allObjectsOnScene.push(voxel);
}

function addSegmentSplited(position) {

    var geometry = new THREE.CubeGeometry(50, 50, 50);

    seg++;
    console.log("ilosc seg:" + seg);
    for (var i = 0; i < geometry.faces.length; i++) {

        geometry.faces[i].color.setHex(0x408080);
    }

    var material = new THREE.MeshLambertMaterial({
        map: map, transparent: false
    });

    var voxel = new THREE.Mesh(geometry, material);
    voxel.name = "Segment_" + voxel.id;
    voxel.position.x = position.x;
    voxel.position.y = position.y;
    voxel.position.z = position.z;
    voxel.matrixAutoUpdate = false;
    voxel.updateMatrix();
    mainContainer.add(voxel);
    var vox=new THREE.Object3D();
    vox=voxel;
    allObjectsOnScene.push(voxel);
}

function splitSegment(voxel) {
    var obj = voxel;
    var parts = obj.geometry.height / 50;
    console.log("parts " + parts);
    console.log(obj);
    split = true;
    if (parts>1)
    {
        voxel.parent.remove(voxel);

        for (var i = 0; i < parts; i += 1) {
            var h = new THREE.Vector3(obj.position.x, 25 + i * 50, obj.position.z);
            //h.addSelf(obj.position);
            //console.log("obj.pos: ");
            //console.log(obj.position);
            //console.log("h: ")
            //console.log(obj.position);
            addSegmentSplited(h);
        }
    }
    split = false;
}

function joinSegments() {
    if (isRDown) {

        var children = mainContainer.children.filter(function (e) {
            return (typeof selObj[e.name] != 'undefined');
        });

        var obj = children[0];
        var group = new THREE.Object3D();
        children.forEach(function (e) {
            group.add(e);
            mainContainer.remove(e);
        });
        mainContainer.add(group);
    }
}

function scaleCubes(dx, dy, dz) {
    console.log("scaleCubes", dx, dy, dz)
    //var children = objects;
    var children = allObjectsOnScene.filter(function (e) {
        return (typeof selObj[e.name] != 'undefined');
    });
    var voxels = [];

    for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child instanceof THREE.Mesh === false)            continue;
        if (child.geometry instanceof THREE.CubeGeometry === false)    continue;

        child.scale.x += dx * child.scale.x;
        child.scale.y += dy * child.scale.y;
        child.scale.z += dz * child.scale.z;

        child.updateMatrix();
    }
}

function translateCubes(dx, dy, dz) {
    console.log("translateCubes", dx, dy, dz)
    //var children = objects;
    var children = allObjectsOnScene.filter(function (e) {
        return (typeof selObj[e.name] != 'undefined');
    });
    var voxels = [];

    for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child instanceof THREE.Mesh === false)            continue;
        if (child.geometry instanceof THREE.CubeGeometry === false)    continue;

        child.position.x += dx * 50;
        child.position.y += dy * 50;
        child.position.z += dz * 50;

        child.updateMatrix();
    }

}


function createGroup() {
    var children = mainContainer.children.filter(function (e) {
        return (typeof selObj[e.name] != 'undefined');
    });
    var tempContainer = new THREE.Object3D();
    children.forEach(function (e) {
        tempContainer.add(e);
    });
    groupContainer.push(tempContainer);
    console.log("create:"+groupContainer.length);
    scene.add(groupContainer[groupContainer.length-1]);

}
function splitGroup() {
    console.log("selindex:"+selectedIndex);
    var children = groupContainer[selectedIndex].children;
    var length = children.length;
    for (var i = length - 1; i >= 0; i--) {
        mainContainer.add(children[i]);
        delete selObj[children.name];
    }
    delete groupContainer[selectedIndex];
    for (i=selectedIndex;i<groupContainer.length;i++){
        groupContainer[i]=groupContainer[i+1];
        groupContainer.length=groupContainer.length-1;
    }
    console.log("split:"+groupContainer.length);
}



function onHeightChange(event) {

    sceneHeight = event.srcElement.value;

    //var children = scene.children.filter(function(e){ return (e.name.substring(0, 7) == "Segment"); });
    var children = mainContainer.children.filter(function (e) {
        return (typeof selObj[e.name] != 'undefined');
    });
    console.log("liczba znalezionych dzieci: " + Object.getOwnPropertyNames(children).length);
    children.forEach(function (e) {
        console.log(e.name);
        var scale = e.scale.y;
        e.scale.y = parseInt(sceneHeight);
        e.position.y = e.geometry.height * e.scale.y / 2;
        e.updateMatrix();
    });
}



function setTexture(obj){
    //TODO
}

function setColor(obj){
    //TODO
}

document.getElementById('input').addEventListener('change', handleFileSelect, false);
var loader = new THREE.SceneLoader();

loader.addGeometryHandler("ctm", THREE.CTMLoader);
loader.addGeometryHandler("vtk", THREE.VTKLoader);
loader.addGeometryHandler("stl", THREE.STLLoader);

loader.addHierarchyHandler("obj", THREE.OBJLoader);
loader.addHierarchyHandler("dae", THREE.ColladaLoader);
loader.addHierarchyHandler("utf8", THREE.UTF8Loader);

loader.load('test.json', callbackFinished);
</script>
</body>
</html>
